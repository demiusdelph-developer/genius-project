**Трансформації**

За допомогою трансформацій можна ефективно працювати з елементами на сторінці, інколи за допомогою властивостей трансформацій можна зміщувати елемент, далі розглянемо чому це може бути ефективніше ніж простими відступами, трансформації дозволяють:
- пересувати елементи
- змінювати масштаб
- повертати елементи

За умовчанням трансформація відбувається щодо центру елемента, але цю поведінку можна змінити

Трансформований елемент - це елемент із будь-яким встановленим значенням властивості transform. 
Види:
- transform: translate() - дозволяє зміщувати елемент по осі х та у можна вказувати 1 параметром наприклад translate(40px) - зміщує на 40рх вправо якби було -40 то було б в ліво, або з 2 параметрів тобто translate(40px, 40px) тобто 40рх вправо і 40рх до низу а 40рх -40рх було б 40 пікселів вправо і 40рх до верху
- transform: perspective() - така властивість дозволяє визначити відстань від задньої точки до юзера, дуже рідко використовується можливо в надскладних елементах і варто використати
- transform: rotate() - дозволяє повертати елемент елемент по осі x y та z може бути в градусах - deg а можна просто вказувати всю вісь x y або z, а ще можна вказувати turn в перекладі оберт можна розглядати як оберт по часовій стрілці наприклад 0.25turn повертає на 90 градусів 0.5turn на 180, 0.75 на 135 градусів але можна і більше дробити тоді це буде інше значення, є ще властивість rotateX() та rotateY() які відповідають окремо за осі х або у але вони надто рыдко використовуються
- transform: rotate3d() - аналогічно працює з rotate але працює сам для повороту 3d тобто має 4 параметри які несуть основну логіку властивості, тобто 4 осі x, y, z Та a Де a відповідає за кут повороту
- transform: scale() - можливість масштабувати елемент або керувати розміром елемента, якщо наприклад задати scale(1.5) то елемент буде збільшений в півтора рази, але можна задати scale(1, 50%) в цій ситуації по осі х тобто зліва направо а іншими словами ширина елемента матиме таку ж ширину як і раніше а 50% говоритиме що по осі у величина елемента тобто висота буде 50%
- transform: scale3d() - аналогічно scale але має 3 точки масштабування по осям x y та z
- transform: skew() - дозволяє деформувати елемент, може бути 

Далі розглянемо CSS-переходи які дозволяють анімувати зміну значення властивості з часом, керуючи швидкістю цього переходу.
Зміна відбувається при настанні певної події, наприклад hover
Перехід має два стани - початкове та кінцеве значення властивості
Властивості:
- transition-property - вказує яку саме властивість нам потрібно анімувати, це може бути фон(background), відступ(margin, padding) та інші
- transition-duration - вказує за який відрізок часу відбувається анімація 1000ms це 1 секунда, зазвичай вказується у значенні цілому або у вигляді дисяткового дробу 0.1s 0.3s 1s
- transition-timing-function - це властивість яка має 6 параметрів, вона регулює вигляд анімації, вигляд формується згідно кубіка бізьє, тобто кожен параметр цієї властивості регулюється відрізком часу, далі показано для кожного параметру відповідні показники
  - linear - cubic-bezier(0.0, 0.0, 1.0, 1.0) тобто на початку анімація не відбувається на 25% пройденого часу анімація ще не відбуваєть на половині часу анімація відображається на всі 100% і на 100% часу анімація залишається на своєму місці
  - easy cubic-bezier(0.25, 0.1, 0.25, 1.0) - анімація на старті вже має 25% анімації на половині часу 100% на 75% знову 25% анімації і на 100% часу маємо кінцевий результат
  - easy-in cubic-bezier(0.42, 0, 1.0, 1.0) - на старті 42% анімації на половині часу знову початок анімації на 75% та 100 бачимо кінцевий результат
  - easy-out cubic-bezier(0, 0, 0.58, 1.0) - на початку та 25% часу анімація не починається на 75% 58% анімації відображається і на 100 бачимо повну анцімацію
  - easy-in-out cubic-bezier(0.42, 0, 0.58, 1.0) - на старті 42% анімації відразу відображається на 25% початковий результат на 75% часу 58% анімації і вкінці кінцевий результат
  - cubic-bezier(p1, p2, p3, p4) це значення яке вказується вручну ось приклад cubic-bezier(0.2, -2, 0.8, 2) в цьому параметрі поєднано всі 4 властивості easy, easy-in, easy-out, easy-in-out
  - steps() допомагає зробити анімацію покрокову але вона не плавна вона ділиться на рівні відрізкиє два варіанти
    - jump - розділяється на start end both none
      - start стартує відразу після початку наприклад у нас анімація складається з 5 кроків довжиною в 2 секунди з jump-start 1 крок буде на 0s другий на 0.4 третій на 0.8 четвертий на 1.2 і п'ятий на 1.6 тобто анімація по суті досягне результату на 1.6
      - end стартує починається з 0.4s другий крок на 0.8 третій на 1.2 четвертий на 1.6 і п'ятий на 2 секунді тобто закінчується анімація в кінці заданого часу анімації
      - both розділить анімацію так щоб на початку і вкінці була затримка тобто якщо ми маємо 5 крокову анімацію то вона має розділитись на 7 частин і на початку та вкінці спостерігатись вона не буде
      - none це коли ми не помітимо затримку ні на початку ні вкінці
      **ці властивості можна задавати без слова jump**
    - step має тільки 2 значення start та end і записується **step-start** та **step-end** і тільки так і не переплутайте з попереднім варіантом інакше рузльтат буде інший
- transition-delay - властивість яка дозволяє задати затримку перед виконанням анімації записується як і transition-duration в секундах або дисятковим дробом
transition - властивість загальна тобто можна вищепереглянуті властивості записати в одну, але бажано дотримуватись послідовності, ось вірна послідовність
transition: delay duration property timing-function 
якщо не дотриматись точної послідовності браузер може скорегувати запис але якщо виникнуть труднощі варто спробувати правильно написати



CSS-анімація
CSS-анімація надає веб-сторінкам динамічність.
На відміну від переходів:
- анімації не потрібен обов'язковий ініціатор (подія) якщо трансформація це дія яка виконується при взаємодії з елементом то анцімація може спрацьовувати самостійно
- її можна повторити нескінченну кількість разів
- між початковим та кінцевим станами може бути будь-яка кількість проміжних станів і це ще одна з переваг над трансформацією оскільки ми можемо корегувати під себе виконання анімації
Для створення анімації оголошується директивою @keyframes в свою чергу в самій дерекктиві ми описуємо послідовність дій які виконує браузер для анімації а для того щоб визначити особливості відображення анімації ми використовуємо наступні властивості:
- animation-name - ця властивість відповідає за назву анімації
- animation-duration - як і у випадку з трансформацією відповідає за час виконанння
- animation-timing-function - теж діє аналогічно до трансформації з властивістю transition-timing-function
- animation-delay - відповідає як і утрансформації за час затримки
- animation-iteration-count - можна вказати кількість раз скільки має виконуватись анімація або вказати infinity - безкінечно, за замовчуванням виконується безкінечно
- animation-play-state дозволяє керувати зупинкою та відтворенням анімації наприклад можна встановити щоб анімація відтворювалась лише при наведенні для цього для Hover можемо задати animation-play-state: running а на самий елемент у нас буде властивість animation-play-state: paused
- animation-direction - дозволяє керувати напрямком анімації:
  - animation-direction: normal - напрямок звичайний
  - animation-direction: reverse - анімація використовується з кінця до початку
  - animation-direction: alternate - анімація відтворюється циклічно спочатку спочатку до кінця а потім у зворотньому напрямку
  - animation-direction: alternate-reverse - початок анімації відбувається з кінця до початку і потім вже рухається вперед назад
- animation-fill-mode - дозволяє визначити положення елемента після виконання анімації є наступні варіанти
  - animation-fill-mode: none - не задає змін працює виключно як ми задали спочатку
  - animation-fill-mode: forwards - вигляд елемента залишається таким яким він став на останньому кадрі, але якщо є задано кількість проходів анімації вони пройдуть і елемент стане таким як відображається на останньому кадрі
  - animation-fill-mode: backwards - в кінці елемент матиме вигляд такий як він мав на самому початку також залежить від кількості проходів
  - animation-fill-mode: both - анімація одночасно комбінує обидва вигляди початковий та кінцевий
Можна працювати з анімацією яка зписується в 1 рядок що має бути зручним але треба бути обережним, ось правильна послідовність запису:
animation: delay direction duration fill-mode iteration-count name play-state timing-function 
в цілому якщо якоїсь із властивостей не буде браузер має скорегувати запис але якщо виникнуть труднощі варто спробувати відтворити точну послідовність


1. JavaScript - скрипт або подія, наприклад ховер або фокус, запускають
анімацію стилів елемента
1. Style – відбувається обчислення нових стилів елементів,
розраховується специфічність, конфлікти, каскадування тощо
1. Layout – розрахунок геометрії елементів. При анімації властивості,
що впливає на геометрію, наприклад margin, браузер обчислює нову
позицію цілої групи елементів
1. Painting - промальовування шарів, тому що елементи вкладені один в
одного або спозиціоновані
1. Composite - компонування всіх підготовлених шарів та малювання
фінальної картинки на екрані