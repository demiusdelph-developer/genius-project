## Підключення стилів

Є 3 варіанти підключення
- **inline** - рядковий, використовується в самому тезі, він не є універсальним і рідко використовується
- **embeded** - вбудований, використовується в тезі head, теж використовується не часто оскільки теж не є універсальним і при використанні такого варіанту застосується лише для поточної сторінки
- **external** - зовнішній, найчастіше використовується оскільки є універсальним, може бути застосований для декількох сторінок, а його підключення відбувається так як і вбудованого в тезі head але при цьому вказується відповідне посилання на файл зі стилями? зазвичай для стилів використовується додатковий(службовий) каталог наприклад css

Всі варіанти підключення продемонстровані в файлі index.html та позначені коментарями

## Про написання css
Блок css коду є правилом, наприклад 
```css 
p {color: white}; 
```
де p це тег, а у фігурних дужках вказуємо пари властивість: значення, у нашому випадку color: white тобто колір: білий, повний перелік властивостей наведений у основному файлі опису гілки де є посилання на довідники які регулярно поновлюються
Далі ми розглянемо селектори.

## Селектори
Селектори це спосіб передачі браузеру даних для розуміння що саме стилізується, селектори бувають наступні:
- селектор тегу - він вказує на певний тег, його актуально використовувати якщо нам потрібно вказати певний тег, з цим селектором потрібно бути обережним оскільки він може стилізувати вказаний тег на всіх сторінках, використовується рідко
- селектор класу - цей варіант вказує на певний класс, в такій ситуації для певного тегу html присвоюється класс, наприклад 
```css 
p {
  color: white;
}
``` 
таким чином ми присвоїли класс color і тепер у файлі стилів можемо його використати для стилізації нашого параграфа, найбільш розповсюджений варіант оскільки такий класс можна задати не одному тегу а декільком що дозволяє зробити цей варіант універсальним і стилізувати декілька тегів одночасно
- селектор атрибуту - за допомогою такого варіанту можна стилізувати тег який має певний атрибут, наприклад:
```css 
[color] {
  color: white;
}
``` 
це актуальний варінт якщо потрібно стилізувати тег з якимось певним атрибутом який повинен мати особливість, така стилізація не використовується як універсальний спосіб
- селектор id(ідентифікатора) - цей варіант вказує на певний ідентифікатор, наприклад:
```css 
#color {
color: white;
}
``` 
найменш розповсюджений оскільки ідентифікатори використовуються переважно для застосування скриптів, проте варто пам'ятати що цей варіант теж можливий

в style.css модуля є базові ці приклади, нижче описано приклади селекторів які можуть бути корисними більш детально

Приклади використання селекторів:
- ***[attr] {};*** вказує на теги в яких є атрибут attr
- ***[attr=value] {};*** - цей варіант вказує на теги у яких атрибут attr має значення value
- ***[attr~=value] {};*** - таким записом ми вказуємо на теги в яких є атрибут value це може бути 'value color' і.т.д
- ***[attr|=value] {};*** - схожий запис до ***[attr*='value']*** з різницею в тому що value- є початком і саме value- з рискою а не іншим знаком
- ***[attr^=value] {};*** - цей запис вказує на клас який починається зі слова value та може бути продовженим будь як
- ***[attr$=value] {};*** - аналогічний до попереднього тільки value має бути вкінці
- ***[attr*=value] {};*** - цей запис вказує на атрибут в якого є слово value всередині
- ***[class*='value']*** {}; - такий варіант запису вказує на класи в яких є слово value частиною класу, це може бути value-red, value-white, value__big, value__small і будь яке інше головне щоб було слово value, якщо раніше ми вказували на атрибут то тут ми вказали клас адже в квадратних дужках ми можемо вказати атрибут а клас по суті і є атрибутом його визначили окремо позначаючи щоб не було помилок

## Комбінатори
Комбінатори дозволяють додатково описувати правила для елементів, це вплине на специфічність яку ми розглянемо далі, оскільки якщо правило задано за допомогою комбінаторів воно має більшу вагу і це означає що для браузера таке правило приорітетніше, розрахувати приорітетність можна згідно специфічності далі, а зараз розглянемо якими можуть бути комбінатори

- ***' ' (.value .key)*** - комбінатор нащадка, як видно в прикладі використовується пробіл між класами це говорить про те що ми задаємо правило для класу key який знаходиться всередині класу value при чому в цьому варіант не має значення глибина вкладеності

- ***' > ' (.value > .key)*** - комбінатор дочірнього елемента, це вказує що правило застосовується для тегу з класом key і вказує жорстко це правило бо не підтримує вкладеності тобто якщо теги будуть 
```html 
<div class="value">
  <div class="value-2">
    <div class="key"></div>
  </div>
</div>
``` 
це працювати не буде

- ***' + ' (.key + .key-2)*** - комбінатор який вказує на сусідні елементи які мають одного батька, наприклад:
```html 
<div class="value">
  <div class="value-2">
    <div class="key"></div>
    <div class="key-2"></div>
    <div class="key-3"></div>
  </div>
</div>
``` 
але ці теги мають бути один біля одного сусідніми якщо між ними буде ще тег такі стилі працювати не будуть

- ***' ~ ' (.key ~ .key-2)*** - комбінатор який вказує на сусідні елементи які мають одного батька, наприклад:
```html 
<div class="value">
  <div class="value-2">
    <div class="key"></div>
    <div class="key-2"></div>
    <div class="key-3"></div>
  </div>
</div>
``` 
варто зазнчаити що цей комбінатор не має обмежень в послідовності сусідів якщо key та key-2 будуть не поруч стилі все одно застосуються навідміну від попереднього варіанту

## Псевдокласи стану

Псевдокласами стану називаються правила які вказують на відображення елементу в тому чи іншому стані, в своїх стилях ми можемо використати такі варіанти:
- hover - стан елемента при наведенні
- focus - стан елемента коли користувач на ньому фокусується за допомогою клавіатури або миші, не використовується для кнопок але для полів може використовуватись
- active - Для кнопок застосовується хоча і рідко ця подія відбувається під час кліку на елемент

## Каскадність

механізм який керує кінцевими значеннями властивостей елемента якщо для нього застосовується кілька css правил використовується кінцеве(останнє значення), тобто якщо з якихось причин тег має декілька однакових властивостей css використовуватись буде останнє, як варіант може бути що будуть використані різні селектори, наприклад правила будуть задані для тегу h1 а в нього по коду також є клас для якого теж є стилі відповідно яка властивість остання така і задіється

## Специфічність

Специфічність це вага селектора, тобто правило може бути вказане як за допомогою одного селектора так і декількох, в файлі style.css показано наглядно


## Наслідування

механізм за допомогою якого значення передається від предка до нащадка, це зручно коли ми записуємо значення для батьківського тегу а в результаті бачимо що властивості застосовуються для всіх тегів всередині.
Ми можемо керувати використанням наслідування, для цього є 3 варіанти:

- inhterit - використовує значення від батьківського тегу якщо таке правило задане у батька, інакше бере значення за замовчуванням від браузера
- initial - бере значення за замовчуванням якщо таке значення існує, наприклад для правила color у браузера дефолтне значення #000 відповідно якщо задати правило color: initial воно буде значити #000
- unset - бере значення у батьківського елемента тобто працює аналогічно з inherit інакше якщо такого значення немає встановлює таке значення як у initial

точного переліку наслідування правил немає оскільки все може залежати як від змін специфікації так і від поточного коду який ми використовуємо, точно не наслідуються ті правила які змінюють розмір елемента тобто height Та width а також ті які мають пряме відношення до цих правил наприклад border-wudth і так далі

